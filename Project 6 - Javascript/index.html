<!DOCTYPE html>
<div>
<head lang="en">
    <meta charset="UTF-8">

    <link rel="stylesheet" type="text/css" href=" css/prism.css">
    <script src=" js/prism.js"></script>
    <!-- jquery -->
    <script src=" js/jquery-2.1.3.js"></script>

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

    <script src="js/functions.js"></script>

    <!-- bootstrap -->
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">

    <!-- jQuery library -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

    <!-- Latest compiled JavaScript -->
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>

    <link rel="stylesheet" type="text/css" href=" css/stylesheet.css">
    <title>Javascript Syntax</title>
</head>

<!-- Nav -->
<div>
<nav class="top-navigation">
    <div class="navbar navbar-default navbar-fixed-top">
        <div class="content">
            <ul class="links">
                <li class="active">Home</li>
                <li><a href="#functions">Syntax</a></li>
                <li><a href="#fizzBuzz">FizzBuzz</a></li>
                <li><a href="#refactor">FizzBuzzRefactor</a></li>
                <li><a href="#truthiness">Truthiness</a></li>
                <li><a href="#objects">Objects</a></li>
            </ul>
            <img class="logo" src=" img/photo.jpg" alt="Logo Image">
        </div>
    </div>
</nav>
<br>

<!-- end nav -->
<!-------------- Section ------------------>
<h5 id="numbersStringsAndThings"><span class="inlineCode" style="font-size:22px;">Comments</span></h5>

<div class="row">
    <div class="col-md-6">
                <pre><code class="language-javascript">
                    // Comments are like C. Single-line comments start with two slashes

                    /* and multiline comments start with slash-star
                    and end with star-slash */

                    // Statements can be terminated by ;

                    <span class="inlineCode">doStuff();</span>

                    // ... but they don't have to be, as semicolons are automatically inserted
                    // wherever there's a newline, except in certain cases.

                    <span class="inlineCode">doStuff()</span>

                    // Because those cases can cause unexpected results, we'll keep on using
                    // semicolons in this guide.
                </code></pre>
    </div>
    <div class="col-md-6">
        <div class="greyBox">
            <ul>
                <li>Loosely typed</li>
                <li>Interpreted</li>
                <li>Functional and OO</li>
                <li><a target="_blank" href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html">No Block Scope/Uses
                    Function Scope</a></li>
                <li>Supports <a target="_blank" href="http://stackoverflow.com/questions/150129/what-is-a-lambda">lambdas</a></li>
                <li>Functions can be passed as parameters - see <a target="_blank"
                        href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">closures</a>
                </li>
                <li>Class Functionality can be acheived as <a target="_blank"
                        href="http://www.w3schools.com/js/js_object_prototypes.asp">Object Prototypes</a> there are no
                    classes
                </li>
                <li><a target="_blank" href="http://stackoverflow.com/questions/7506844/javascript-function-scoping-and-hoisting">Hoisting</a>
                </li>
                <li>Objects in JS can be thought of as name value pairs similar dictionaries in python anonymous
                    functions
                </li>
                <li><a href="https://tldrify.com/7zg" target="_blank">Anonymous Functions</a></li>
            </ul>
            <br>
        </div>
    </div>
</div>
<div class="row">
    <div class="col-md-6">
        <h5 id="numbersStringsAndThings"><span class="inlineCode" style="font-size:22px;">Numbers</span></h5>
                <pre><code class="language-javascript">
                    // JavaScript has one number type (which is a 64-bit IEEE 754 double).
                    // Doubles have a 52-bit mantissa, which is enough to store integers
                    // up to about 9✕10¹⁵ precisely.
                    3; // = 3
                    1.5; // = 1.5

                    // Some basic arithmetic works as you'd expect.
                    1 + 1; // = 2
                    0.1 + 0.2; // = 0.30000000000000004
                    8 - 1; // = 7
                    10 * 2; // = 20
                    35 / 5; // = 7

                    // Including uneven division.
                    5 / 2; // = 2.5

                    // Bitwise operations also work; when you perform a bitwise operation your float
                    // is converted to a signed int *up to* 32 bits.
                    1 << 2; // = 4

                    // Precedence is enforced with parentheses.
                    (1 + 3) * 2; // = 8

                    // There are three special not-a-real-number values:
                    Infinity; // result of e.g. 1/0
                    -Infinity; // result of e.g. -1/0
                    NaN; // result of e.g. 0/0
                </code></pre>
    </div>
    <div class="col-md-6">
        <h5 id="numbersStringsAndThings"><span class="inlineCode" style="font-size:22px;">Booleans</span></h5>
        <pre><code class="language-javascript">

            // There's also a boolean type.
            true;
            false;

            // Negation uses the ! symbol
            !true; // = false
            !false; // = true

            // Equality is ===
            1 === 1; // = true
            2 === 1; // = false

            // Inequality is !==
            1 !== 1; // = false
            2 !== 1; // = true

            // More comparisons
            1 < 10; // = true
            1 > 10; // = false
            2 <= 2; // = true
            2 >= 2; // = true

            // and are compared with < and >
            "a" < "b"; // = true

            // Type coercion is performed for comparisons with double equals...
            "5" == 5; // = true
            null == undefined; // = true

            // ...unless you use ===
            "5" === 5; // = false
            null === undefined; // = false

            // ...which can result in some weird behaviour...
            13 + !0; // 14
            "13" + !0; // '13true'
        </code></pre>
    </div>
</div>
<div class="row">
    <div class="col-md-6">
        <h5 id="strings"><span class="inlineCode" style="font-size:22px;">Strings</span></h5>
            <pre><code class="language-javascript">

                // Strings are created with ' or ".
                'abc';
                "Hello, world";

                // Strings are concatenated with +
                "Hello " + "world!"; // = "Hello world!"

                // You can access characters in a string with `charAt`
                "This is a string".charAt(0); // = 'T'

                // ...or use `substring` to get larger pieces.
                "Hello world".substring(0, 5); // = "Hello"

                // `length` is a property, so don't use ().
                "Hello".length; // = 5

                // There's also `null` and `undefined`.
                null; // used to indicate a deliberate non-value
                undefined; // used to indicate a value is not currently present (although
                // `undefined` is actually a value itself)

                // false, null, undefined, NaN, 0 and "" are falsy; everything else is truthy.
                // Note that 0 is falsy and "0" is truthy, even though 0 == "0".

            </code></pre>
    </div>
    <div class="col-md-6">
        <h5 id="variables"><span class="inlineCode" style="font-size:22px;">Variables</span></h5>
                <pre><code class="language-javascript">


                    ///////////////////////////////////
                    // 2. Variables, Arrays and Objects

                    // Variables are declared with the `var` keyword. JavaScript is dynamically
                    // typed, so you don't need to specify type. Assignment uses a single `=`
                    // character.
                    var someVar = 5;

                    // if you leave the var keyword off, you won't get an error...
                    someOtherVar = 10;

                    // ...but your variable will be created in the global scope, not in the scope
                    // you defined it in.

                    // Variables declared without being assigned to are set to undefined.
                    var someThirdVar; // = undefined

                    // There's shorthand for performing math operations on variables:
                    someVar += 5; // equivalent to someVar = someVar + 5; someVar is 10 now
                    someVar *= 10; // now someVar is 100

                    // and an even-shorter-hand for adding or subtracting 1
                    someVar++; // now someVar is 101
                    someVar--; // back to 100
                </code></pre>
    </div>
    </div>
</div>
<div class="row">
    <div class="col-md-6">
        <h5 id="Arrays"><span class="inlineCode" style="font-size:22px;">Arrays</span></h5>
         <pre><code class="language-javascript">

             // Arrays are ordered lists of values, of any type.
             var myArray = ["Hello", 45, true];

             // Their members can be accessed using the square-brackets subscript syntax.
             // Array indices start at zero.
             myArray[1]; // = 45

             // Arrays are mutable and of variable length.
             myArray.push("World");
             myArray.length; // = 4

             // Add/Modify at specific index
             myArray[3] = "Hello";

             // JavaScript's objects are equivalent to "dictionaries" or "maps" in other
             // languages: an unordered collection of key-value pairs.
             var myObj = {key1: "Hello", key2: "World"};

             // Keys are strings, but quotes aren't required if they're a valid
             // JavaScript identifier. Values can be any type.
             var myObj = {myKey: "myValue", "my other key": 4};

             // Object attributes can also be accessed using the subscript syntax,
             myObj["my other key"]; // = 4

             // ... or using the dot syntax, provided the key is a valid identifier.
             myObj.myKey; // = "myValue"

             // Objects are mutable; values can be changed and new keys added.
             myObj.myThirdKey = true;

             // If you try to access a value that's not yet set, you'll get undefined.
             myObj.myFourthKey; // = undefined

         </code></pre>
    </div>
    <div class="col-md-6">
        <h5 id="control"><span class="inlineCode" style="font-size:22px;">Control Structures</span></h5>
                <pre><code class="language-javascript">


                    ///////////////////////////////////
                    // 3. Logic and Control Structures

                    // The syntax for this section is almost identical to Java's.

                    // The `if` structure works as you'd expect.
                    var count = 1;
                    if (count == 3){
                    // evaluated if count is 3
                    } else if (count == 4){
                    // evaluated if count is 4
                    } else {
                    // evaluated if it's not either 3 or 4
                    }

                    // As does `while`.
                    while (true){
                    // An infinite loop!
                    }

                    // Do-while loops are like while loops, except they always run at least once.
                    var input;
                    do {
                    input = getInput();
                    } while (!isValid(input))

                    // The `for` loop is the same as C and Java:
                    // initialisation; continue condition; iteration.
                    for (var i = 0; i < 5; i++){
                    // will run 5 times
                    }

                    // && is logical and, || is logical or
                    if (house.size == "big" && house.colour == "blue"){
                    house.contains = "bear";
                    }
                    if (colour == "red" || colour == "blue"){
                    // colour is either red or blue
                    }

                    // && and || "short circuit", which is useful for setting default values.
                    var name = otherName || "default";


                    // The `switch` statement checks for equality with `===`.
                    // use 'break' after each case
                    // or the cases after the correct one will be executed too.
                    grade = 'B';
                    switch (grade) {
                    case 'A':
                    console.log("Great job");
                    break;
                    case 'B':
                    console.log("OK job");
                    break;
                    case 'C':
                    console.log("You can do better");
                    break;
                    default:
                    console.log("Oy vey");
                    break;
                    }


                </code></pre>
    </div>
</div>

<div class="row">
    <div class="col-md-6">
        <h5 id="Arrays"><span class="inlineCode" style="font-size:22px;">Functions</span></h5>
                <pre><code class="language-javascript">


                    ///////////////////////////////////
                    // 4. Functions, Scope and Closures

                    // JavaScript functions are declared with the `function` keyword.
                    function myFunction(thing){
                    return thing.toUpperCase();
                    }
                    myFunction("foo"); // = "FOO"

                    // Note that the value to be returned must start on the same line as the
                    // `return` keyword, otherwise you'll always return `undefined` due to
                    // automatic semicolon insertion. Watch out for this when using Allman style.
                    function myFunction()
                    {
                    return // <- semicolon automatically inserted here
                    {
                    thisIsAn: 'object literal'
                    }
                    }
                    myFunction(); // = undefined

                    // JavaScript functions are first class objects, so they can be reassigned to
                    // different variable names and passed to other functions as arguments - for
                    // example, when supplying an event handler:
                    function myFunction(){
                    // this code will be called in 5 seconds' time
                    }
                    setTimeout(myFunction, 5000);
                    // Note: setTimeout isn't part of the JS language, but is provided by browsers
                    // and Node.js.

                    // Function objects don't even have to be declared with a name - you can write
                    // an anonymous function definition directly into the arguments of another.
                    setTimeout(function(){
                    // this code will be called in 5 seconds' time
                    }, 5000);

                    // JavaScript has function scope; functions get their own scope but other blocks
                    // do not.
                    if (true){
                    var i = 5;
                    }
                    i; // = 5 - not undefined as you'd expect in a block-scoped language

                    // This has led to a common pattern of "immediately-executing anonymous
                    // functions", which prevent temporary variables from leaking into the global
                    // scope.
                    (function(){
                    var temporary = 5;
                    // We can access the global scope by assiging to the "global object", which
                    // in a web browser is always `window`. The global object may have a
                    // different name in non-browser environments such as Node.js.
                    window.permanent = 10;
                    })();
                    temporary; // raises ReferenceError
                    permanent; // = 10

                    // One of JavaScript's most powerful features is closures. If a function is
                    // defined inside another function, the inner function has access to all the
                    // outer function's variables, even after the outer function exits.
                    function sayHelloInFiveSeconds(name){
                    var prompt = "Hello, " + name + "!";
                    // Inner functions are put in the local scope by default, as if they were
                    // declared with `var`.
                    function inner(){
                    alert(prompt);
                    }
                    setTimeout(inner, 5000);
                    // setTimeout is asynchronous, so the sayHelloInFiveSeconds function will
                    // exit immediately, and setTimeout will call inner afterwards. However,
                    // because inner is "closed over" sayHelloInFiveSeconds, inner still has
                    // access to the `prompt` variable when it is finally called.
                    }
                    sayHelloInFiveSeconds("Adam"); // will open a popup with "Hello, Adam!" in 5s

                </code></pre>
    </div>

    <div class="col-md-6">
        <h5 id="objects"><span class="inlineCode" style="font-size:22px;">Objects</span></h5>
                <pre><code class="language-javascript">


                    ///////////////////////////////////
                    // 5. More about Objects; Constructors and Prototypes

                    // Objects can contain functions.
                    var myObj = {
                    myFunc: function(){
                    return "Hello world!";
                    }
                    };
                    myObj.myFunc(); // = "Hello world!"

                    // When functions attached to an object are called, they can access the object
                    // they're attached to using the `this` keyword.
                    myObj = {
                    myString: "Hello world!",
                    myFunc: function(){
                    return this.myString;
                    }
                    };
                    myObj.myFunc(); // = "Hello world!"

                    // What this is set to has to do with how the function is called, not where
                    // it's defined. So, our function doesn't work if it isn't called in the
                    // context of the object.
                    var myFunc = myObj.myFunc;
                    myFunc(); // = undefined

                    // Inversely, a function can be assigned to the object and gain access to it
                    // through `this`, even if it wasn't attached when it was defined.
                    var myOtherFunc = function(){
                    return this.myString.toUpperCase();
                    }
                    myObj.myOtherFunc = myOtherFunc;
                    myObj.myOtherFunc(); // = "HELLO WORLD!"

                    // We can also specify a context for a function to execute in when we invoke it
                    // using `call` or `apply`.

                    var anotherFunc = function(s){
                    return this.myString + s;
                    }
                    anotherFunc.call(myObj, " And Hello Moon!"); // = "Hello World! And Hello Moon!"

                    // The `apply` function is nearly identical, but takes an array for an argument
                    // list.

                    anotherFunc.apply(myObj, [" And Hello Sun!"]); // = "Hello World! And Hello Sun!"

                    // This is useful when working with a function that accepts a sequence of
                    // arguments and you want to pass an array.

                    Math.min(42, 6, 27); // = 6
                    Math.min([42, 6, 27]); // = NaN (uh-oh!)
                    Math.min.apply(Math, [42, 6, 27]); // = 6

                    // But, `call` and `apply` are only temporary. When we want it to stick, we can
                    // use `bind`.

                    var boundFunc = anotherFunc.bind(myObj);
                    boundFunc(" And Hello Saturn!"); // = "Hello World! And Hello Saturn!"

                    // `bind` can also be used to partially apply (curry) a function.

                    var product = function(a, b){ return a * b; }
                    var doubler = product.bind(this, 2);
                    doubler(8); // = 16

                    // When you call a function with the `new` keyword, a new object is created, and
                    // made available to the function via the this keyword. Functions designed to be
                    // called like that are called constructors.

                    var MyConstructor = function(){
                    this.myNumber = 5;
                    }
                    myNewObj = new MyConstructor(); // = {myNumber: 5}
                    myNewObj.myNumber; // = 5

                    // Every JavaScript object has a 'prototype'. When you go to access a property
                    // on an object that doesn't exist on the actual object, the interpreter will
                    // look at its prototype.

                    // Some JS implementations let you access an object's prototype on the magic
                    // property `__proto__`. While this is useful for explaining prototypes it's not
                    // part of the standard; we'll get to standard ways of using prototypes later.
                    var myObj = {
                    myString: "Hello world!"
                    };
                    var myPrototype = {
                    meaningOfLife: 42,
                    myFunc: function(){
                    return this.myString.toLowerCase()
                    }
                    };

                    myObj.__proto__ = myPrototype;
                    myObj.meaningOfLife; // = 42

                    // This works for functions, too.
                    myObj.myFunc(); // = "hello world!"

                    // Of course, if your property isn't on your prototype, the prototype's
                    // prototype is searched, and so on.
                    myPrototype.__proto__ = {
                    myBoolean: true
                    };
                    myObj.myBoolean; // = true

                    // There's no copying involved here; each object stores a reference to its
                    // prototype. This means we can alter the prototype and our changes will be
                    // reflected everywhere.
                    myPrototype.meaningOfLife = 43;
                    myObj.meaningOfLife; // = 43

                    // We mentioned that `__proto__` was non-standard, and there's no standard way to
                    // change the prototype of an existing object. However, there are two ways to
                    // create a new object with a given prototype.

                    // The first is Object.create, which is a recent addition to JS, and therefore
                    // not available in all implementations yet.
                    var myObj = Object.create(myPrototype);
                    myObj.meaningOfLife; // = 43

                    // The second way, which works anywhere, has to do with constructors.
                    // Constructors have a property called prototype. This is *not* the prototype of
                    // the constructor function itself; instead, it's the prototype that new objects
                    // are given when they're created with that constructor and the new keyword.
                    MyConstructor.prototype = {
                    myNumber: 5,
                    getMyNumber: function(){
                    return this.myNumber;
                    }
                    };
                    var myNewObj2 = new MyConstructor();
                    myNewObj2.getMyNumber(); // = 5
                    myNewObj2.myNumber = 6
                    myNewObj2.getMyNumber(); // = 6

                    // Built-in types like strings and numbers also have constructors that create
                    // equivalent wrapper objects.
                    var myNumber = 12;
                    var myNumberObj = new Number(12);
                    myNumber == myNumberObj; // = true

                    // Except, they aren't exactly equivalent.
                    typeof myNumber; // = 'number'
                    typeof myNumberObj; // = 'object'
                    myNumber === myNumberObj; // = false
                    if (0){
                    // This code won't execute, because 0 is falsy.
                    }
                    if (Number(0)){
                    // This code *will* execute, because Number(0) is truthy.
                    }

                    // However, the wrapper objects and the regular builtins share a prototype, so
                    // you can actually add functionality to a string, for instance.
                    String.prototype.firstCharacter = function(){
                    return this.charAt(0);
                    }
                    "abc".firstCharacter(); // = "a"

                    // This fact is often used in "polyfilling", which is implementing newer
                    // features of JavaScript in an older subset of JavaScript, so that they can be
                    // used in older environments such as outdated browsers.

                    // For instance, we mentioned that Object.create isn't yet available in all
                    // implementations, but we can still use it with this polyfill:
                    if (Object.create === undefined){ // don't overwrite it if it exists
                    Object.create = function(proto){
                    // make a temporary constructor with the right prototype
                    var Constructor = function(){};
                    Constructor.prototype = proto;
                    // then use it to create a new, appropriately-prototyped object
                    return new Constructor();
                    }
                    }


                </code></pre>
    </div>
</div>
<br>

    <h5 id="FunctionScope"><span class="inlineCode" style="font-size:22px;">Function Scope</span></h5>

<div class="row">
    <div class="col-md-4">
                <pre><code class="language-javascript">
                    var foo = 1;
                    function bar() {
                    if (!foo) {
                    var foo = 10;
                    }
                    alert(foo);
                    }
                    bar();
                </code>
                </pre>

    </div>
    <div class="col-md-6"><p>foo = 1 is outside the class. Returns 10</p></div>
</div>
<div class="row">
    <div class="col-md-4">
                <pre><code class="language-javascript">
                    var a = 1;
                    function b() {
                    a = 10;
                    return;
                    function a() {}
                    }
                    b();
                    alert(a);
                </code>
                </pre>

    </div>
    <div class="col-md-6"><p>Here, of course, the browser will alert “1”. So what’s going on here? While it might seem
        strange, dangerous, and confusing, this is actually a powerful and expressive feature of the language. I don’t
        know if there is a standard name for this specific behavior, but I’ve come to like the term “hoisting”. This
        article will try to shed some light on this mechanism, but first lets take a necessary detour to understand
        JavaScript’s scoping.</p></div>
</div>
<div class="row">
    <div class="col-md-4">
                <pre><code class="language-javascript">
                    var x = 1;
                    console.log(x); // 1
                    if (true) {
                    var x = 2;
                    console.log(x); // 2
                    }
                    console.log(x); // 2

                    //creating new scope within a function
                    function foo() {
                    var x = 1;
                    if (x) {
                    (function () {
                    var x = 2;
                    // some other code
                    }());
                    }
                    // x is still 1.
                    }
                </code>
                </pre>

    </div>
    <div class="col-md-6"><p>Will output 1,2,2 as shown. Blocks in js do not create new scope!! Important - this is
        called function level scope. Only functions create a new scope!</p></div>
</div>
<div class="row">
    <div class="col-md-4">
                <pre><code class="language-javascript">
                    function foo() {
                    bar();
                    var x = 1;
                    }
                    is actually interpreted like this:

                    function foo() {
                    var x;
                    bar();
                    x = 1;
                    }
                </code>
                </pre>

    </div>
    <div class="col-md-6"><p>Function declarations and variable declarations are always moved (“hoisted”) invisibly to
        the top of their containing scope by the JavaScript interpreter. Function parameters and language-defined names
        are, obviously, already there.</p></div>
</div>
    <h5 id="fizzBuzz"><span class="inlineCode" style="font-size:22px;">FizzBuzz</span></h5>

<div class="row">
    <div class="col-md-4"><pre><code class="language-javascript">
        console.log("array apply",
        Array.apply(null, {length: 100}).map(function(val, index) {
        index++;
        if (index % 15 == 0){return "FizzBuzz";}
        if (index % 3 == 0){return "Fizz";}
        if (index % 5 == 0){return "Buzz";}
        return index;
        }).join('\n')
        );
    </code></pre>
    </div>
    <div class="col-md-4"><pre><code class="language-javascript">
        function fizzbuzz(max) {
        for ( var i = 1; i <= max; i++ ) {
        if (i % 5 == 0 && i % 3 == 0) {
        cprint("FizzBuzz");
        } else if ( i % 3 == 0 ) {
        cprint("Fizz");
        } else if (i % 5 == 0) {
        cprint("Buzz");
        } else {
        cprint(i);
        }
        }
        }
    </code></pre>
    </div>
    <div class="col-md-4"><pre><code class="language-javascript">
        for (var i=1; i <= 20; i++) {
        if (i % 15 == 0)
        console.log("FizzBuzz");
        else if (i % 3 == 0)
        console.log("Fizz");
        else if (i % 5 == 0)
        console.log("Buzz");
        else
        console.log(i);
        }
    </code></pre>
    </div>
</div>
    <h5 id="refactor"><span class="inlineCode" style="font-size:22px;">FizzBuzz Refactor</span></h5>
<section class="refactor">
    <div class="row">
        <div class="col-md-4">
            <h5><em>Steps for this program</em></h5>
            <ul>
                <li>When the page loads, the user should be prompted to supply a number. The easiest way to do this
                    would be with the prompt() function, but you should also feel free to create a simple text input
                    with text telling the user to input a number.
                </li>
                <li>You’ll need to write one named function that takes an integer as argument, and then counts from 1 to
                    the argument value, substituting “fizz”, “buzz”, and “fizzbuzz” accordingly.
                </li>
                <li>You’ll need to convert the value the user supplies from a string to a number. Remember that the
                    value that you get from prompt() or the val() on your form will by default be a string. To convert
                    this to an integer you can use the + operator to convert a string to an integer. For instance, if
                    you had the string “22”, you could convert that to a number with +”22”.
                </li>
                <li>Note that if you try to convert something like "this is a string" to an integer with +"this is a
                    string", it will evaluate to NaN. Your app should ensure that the user supplied value does not
                    evaluate to NaN. If it does, you should supply a message telling them they need to supply a number.
                </li>
                <li>Optionally, you can also write code to ensure that the user has not supplied a decimal value. For an
                    easy way to do this, check out <a
                            href="http://stackoverflow.com/questions/2304052/check-if-a-number-has-a-decimal-place-is-a-whole-number/2304062#2304062"
                            alt="" target="_blank">this answer</a> on Stack Overflow.
                </li>
                <li><strong>DO NOT</strong> spend any time thinking about design for this app. Like the first version,
                    the goal here is not to create a pretty app, but instead to hone your JavaScript skills.
                </li>
            </ul>
        </div>
        <div class="col-md-8">
            <h5>Click to play</h5>
            <ul id="fizz">

            </ul>
            <button id="fb">fizzbuzz</button>

        </div>
    </div>

</section>
    <h5 id="truthiness"><span class="inlineCode" style="font-size:22px;">Truthiness</span></h5>

<div class="row">
    <div class="col-md-12">
        <div class="col-md-4">
            <div class="greyBox">
                <ul class="list-group">
                    <h5 class="list-group-item-heading">Truthiness (Falsy Values)</h5>
                    <li class="list-group-item">Boolean value false</li>
                    <li class="list-group-item">the empty string ""</li>
                    <li class="list-group-item">the number 0 or -0</li>
                    <li class="list-group-item">null</li>
                    <li class="list-group-item">undefined</li>
                    <li class="list-group-item">NaN (not a number)</li>
                </ul>
            </div>
        </div>
        <div class="col-md-8">
            <ul>
                <li>When we say that a value is <span class="inlineCode">"truthy"</span> in JavaScript, we don't just
                    mean that the value is <span class="inlineCode">true</span>. Rather, what we mean is that the value
                    coerces to <span class="inlineCode">true</span> when evaluated in a <span
                            class="inlineCode">boolean</span> context.
                </li>
                <li>There are a lot of <span class="inlineCode">truthy</span> values in JavaScript. And there are many
                    more than could be listed here. On the other side, though, there are only six <span
                            class="inlineCode">falsy</span> values.
                </li>
            </ul>
        </div>
        </pre></div>
</div>
</body>
</html>